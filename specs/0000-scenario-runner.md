# Scenario Runner

Feature name: scenario-runner  
Start date: 2019-10-02

## Note

This spec is a work in progress at the moment, which is why it contains additional sections: [Possible future extensions](##Possible-future-extensions) and [Things to consider](##Things-to-consider-/-gotchas). Once we agree the requirements on [Guide-level](##Guide-level-explanation) these will get integrated into other sections or moved to a separate document and the [Reference-level explanation](##Reference-level-explanation) will get extended with implementation-level detail.

## Summary

Scenario runner is a tool for exploratory testing and analysis of the Vega network.
It can submit instructions in bulk, generate a list of instructions to transform a newly instantiated network to a pre-recorded state and extract outputs related to trading activity.

## Guide-level explanation

Scenario runner is a command-line tool used for interacting with the instance of a Vega network. It can submit all the trading and collateral management-related instructions defined in the protocol. It can be pointed at a running node (local or otherwise) or at `trading-core` running without Blockchain for maximum performance and throughput.

The main functionality is:

- `LoadState`: Reads a set of instructions from a `StateFile` and submits them to the network.
  (From David's spec: price history, order book, every trader's position)
- `SaveState`: Generates a set of instructions necessary to replicate current state of the network and outputs them as a `StateFile`.
- `ExtractData`: Extracts the trading data from the network subject to additional, user-defined filtering and outputs it as `DataFile`.
  (From David's spec: inspect the state of the Vega engine afterwards (e.g. all trader positions, their margin account amounts and)
- **TODO (WG 8/10/19) Discuss:** We probably need the option to add trading logic which works algorithmically as opposed to reading a static set of instructions

## Reference-level explanation

- `StateFile` - supported data formats:
  - JSON
  - <mark>CSV??? - Do we need it? How much extra maintenance will it be (versioning might be a bit convoluted)?</mark>
  - <mark> ??? - Do we require anything else?</mark>
- `DataFile` needs to support further querying and slicing of data using generally available languages and tools. The suppored formats are:
  - JSON
  - SQLite ??? - Is there enough need / appetite for it?
  - <mark> ??? - Do we require anything else?</mark>

### Architecture

- Where do we want to keep the code:
  - Seprate repo?
    - Cleaner.
    - Decoupled from the `trading-core`.
    - Less risk of introducing bugs to other parts of the codebase.
  - Folder within `trading-core/cmd`?
    - Will always be keep in sync with `trading-core`.
    - Code in `internal` accessible.

## Pseudo-code / Examples

## Test cases

- Check that the `SaveState` and `LoadState` functionality roundtrips
  - Take a saved state
  - Load it on a clean instance of the network
  - Save state
  - Check if the two `StateFiles` match

## Possible future extensions

- Add bots
- "Diff" network states with SR (from David's spec: compare another pre-saved state of Vega with the one generated by the scenario
  This is for general regression testing / continuous integration.)
- Extend set of available commands to allow a more in-depth testing of the network (node failures etc.)
  (From David's spec: Run things across a network (or locally) but pretending we have several nodes (with consensus), that can be killed, re-started and poked with, ideally via a script.
  This is for more complex network interaction modelling of the whole network.)

- Include a backtesting framework to facilitate evaluation of investment strategies.
- Add a UI.

  - Adhere to conventions followed in the `client` repo so that the scenario runner UI can be used both standalone and as a component withing the main UI.

## Things to consider

- The concept of time
  - How do we inform the node of time?
  - Will need to distinguish between relative and absolute time.
  - We may want to translate something like an order expiring at 3.45pm today into an order expiring 3h from the base time of 12.45pm when we `save state`.
  - At the same time we may want to keep the maturity of the Dec19 futures contract fixed in absolute terms.
  - We will need a fairly flexible config file to accommodate both (and more).
- Deltas
  - Do we want to be able to `load state` onto existing network instance that already has a state (so more like `append state`)?
    - if we do then we will need to consider how we handle duplicate account IDs - e.g. there's already a "Trader1" account on a node that we're pointing out with a balance of \$1 and the state file contains the same account with balance $2 - do we want to end up with \$1,\$2,\$3? Do we want to assume any or control from config? - if so is that a setting for the `save state` or `load state` function?
- Config
  - Looking at previous points we may end up with a fairly complex config file.
    - Need to balance usability and flexibility.
      - Probably best to offer a set of predefined configs with sensible naming convetion and ability to customize them.
- Versioning
  - It's quite likely that we will end up adding more node instructions and/or modify the existing ones.
  - By that time we may already have a large collection of scenario runner `StateFile`s
  - Need to build in backwards compability or a way of updating them to the latest standard as considerable time and effort might have been put into generating some of them and the process might not be easy to reprodce (scrips that get lost or become stale, manual fine-tuning of certain values etc.)

##David's spec

### Requirements

At the very least we want to be able to:

- ~~run things locally on a laptop without a network connection (without consensus)~~
- ~~load state (price history, order book, every trader's position)~~
- ~~inspect the state of the Vega engine afterwards (e.g. all trader positions, their margin account amounts and~~
- ~~in a different mode let several bots trade and be able to observe state~~
  This is for quant / scenario testing.

Later for regression testing:

- ~~compare another pre-saved state of Vega with the one generated by the scenario
  This is for general regression testing / continuous integration.~~

Even later

- ~~Run things across a network (or locally) but pretending we have several nodes (with consensus), that can be killed, re-started and poked with, ideally via a script.
  This is for more complex network interaction modelling of the whole network.~~

## Meeting notes

Categories

Commands:

- Things that can push things into trading core
  - All of GRPC msgs to core
  - Movement of time or creation of extra blocks (needs additional things)
  - CSV / graph trans in file good for now
    - Make sure well defined so in future we can make version easily

Output

- What data are we expecting to expose from the core
  - GRPC msgs output from the core
  - Things that are not exposed to read stores from core
  - Data that we don’t expose by any points but need to make changes to core
- What can we do with that data
  - Dump to store to sqlite or CSV, for Excel or Python
- Dump all open orders that party has
- Dump all trades
- Streaming all trades
- Streaming all orders

Post-processing

- Future post processing tools on data

* Commands to scenario runner
  - !dump_order_book command - which dump bits of state
  - !change_market_mode - goto auction, scenario runner effectively
  - !time_step - increment time once, step time —> Create a ticket to agree and merge to md
  - !deposit_funds
  - !withdraw_funds
  - !transfers - double entry book keeping, dump those for one or all account
